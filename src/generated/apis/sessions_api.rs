/*
 * Agno AgentOS
 *
 * Nurok AI's Agent OS
 *
 * The version of the OpenAPI document: 1.0.0
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{ContentType, Error, configuration};
use crate::generated::{apis::ResponseContent, models};
use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};

/// struct for typed errors of method [`create_session`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSessionError {
    Status400(models::BadRequestResponse),
    Status401(models::UnauthenticatedResponse),
    Status404(models::NotFoundResponse),
    Status422(models::ValidationErrorResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_session`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSessionError {
    Status400(models::BadRequestResponse),
    Status401(models::UnauthenticatedResponse),
    Status404(models::NotFoundResponse),
    Status422(models::ValidationErrorResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_sessions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSessionsError {
    Status400(models::BadRequestResponse),
    Status401(models::UnauthenticatedResponse),
    Status404(models::NotFoundResponse),
    Status422(models::ValidationErrorResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_session_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSessionByIdError {
    Status400(models::BadRequestResponse),
    Status401(models::UnauthenticatedResponse),
    Status404(models::NotFoundResponse),
    Status422(models::ValidationErrorResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_session_run`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSessionRunError {
    Status400(models::BadRequestResponse),
    Status401(models::UnauthenticatedResponse),
    Status404(models::NotFoundResponse),
    Status422(models::ValidationErrorResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_session_runs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSessionRunsError {
    Status400(models::BadRequestResponse),
    Status401(models::UnauthenticatedResponse),
    Status404(models::NotFoundResponse),
    Status422(models::ValidationErrorResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_sessions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSessionsError {
    Status400(models::BadRequestResponse),
    Status401(models::UnauthenticatedResponse),
    Status404(models::NotFoundResponse),
    Status422(models::ValidationErrorResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`rename_session`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RenameSessionError {
    Status400(models::BadRequestResponse),
    Status401(models::UnauthenticatedResponse),
    Status404(models::NotFoundResponse),
    Status422(models::ValidationErrorResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_session`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSessionError {
    Status400(models::BadRequestResponse),
    Status401(models::UnauthenticatedResponse),
    Status404(models::NotFoundResponse),
    Status422(models::ValidationErrorResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// Create a new empty session with optional configuration. Useful for pre-creating sessions with specific session_state, metadata, or other properties before running any agent/team/workflow interactions. The session can later be used by providing its session_id in run requests.
pub async fn create_session(
    configuration: &configuration::Configuration,
    r#type: Option<models::SessionType>,
    db_id: Option<&str>,
    create_session_request: Option<models::CreateSessionRequest>,
) -> Result<models::ResponseCreateSession, Error<CreateSessionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_type = r#type;
    let p_query_db_id = db_id;
    let p_body_create_session_request = create_session_request;

    let uri_str = format!("{}/sessions", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_db_id {
        req_builder = req_builder.query(&[("db_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_create_session_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::ResponseCreateSession`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::ResponseCreateSession`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateSessionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Permanently delete a specific session and all its associated runs. This action cannot be undone and will remove all conversation history.
pub async fn delete_session(
    configuration: &configuration::Configuration,
    session_id: &str,
    db_id: Option<&str>,
) -> Result<(), Error<DeleteSessionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_session_id = session_id;
    let p_query_db_id = db_id;

    let uri_str = format!(
        "{}/sessions/{session_id}",
        configuration.base_path,
        session_id = crate::generated::apis::urlencode(p_path_session_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_query_db_id {
        req_builder = req_builder.query(&[("db_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteSessionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Delete multiple sessions by their IDs in a single operation. This action cannot be undone and will permanently remove all specified sessions and their runs.
pub async fn delete_sessions(
    configuration: &configuration::Configuration,
    delete_session_request: models::DeleteSessionRequest,
    r#type: Option<models::SessionType>,
    db_id: Option<&str>,
) -> Result<(), Error<DeleteSessionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_delete_session_request = delete_session_request;
    let p_query_type = r#type;
    let p_query_db_id = db_id;

    let uri_str = format!("{}/sessions", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_db_id {
        req_builder = req_builder.query(&[("db_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_delete_session_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteSessionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Retrieve detailed information about a specific session including metadata, configuration, and run history. Response schema varies based on session type (agent, team, or workflow).
pub async fn get_session_by_id(
    configuration: &configuration::Configuration,
    session_id: &str,
    r#type: Option<models::SessionType>,
    user_id: Option<&str>,
    db_id: Option<&str>,
) -> Result<models::ResponseGetSessionById, Error<GetSessionByIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_session_id = session_id;
    let p_query_type = r#type;
    let p_query_user_id = user_id;
    let p_query_db_id = db_id;

    let uri_str = format!(
        "{}/sessions/{session_id}",
        configuration.base_path,
        session_id = crate::generated::apis::urlencode(p_path_session_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_user_id {
        req_builder = req_builder.query(&[("user_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_db_id {
        req_builder = req_builder.query(&[("db_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::ResponseGetSessionById`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::ResponseGetSessionById`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSessionByIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Retrieve a specific run by its ID from a session. Response schema varies based on the run type (agent run, team run, or workflow run).
pub async fn get_session_run(
    configuration: &configuration::Configuration,
    session_id: &str,
    run_id: &str,
    r#type: Option<models::SessionType>,
    user_id: Option<&str>,
    db_id: Option<&str>,
) -> Result<models::ResponseGetSessionRun, Error<GetSessionRunError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_session_id = session_id;
    let p_path_run_id = run_id;
    let p_query_type = r#type;
    let p_query_user_id = user_id;
    let p_query_db_id = db_id;

    let uri_str = format!(
        "{}/sessions/{session_id}/runs/{run_id}",
        configuration.base_path,
        session_id = crate::generated::apis::urlencode(p_path_session_id),
        run_id = crate::generated::apis::urlencode(p_path_run_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_user_id {
        req_builder = req_builder.query(&[("user_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_db_id {
        req_builder = req_builder.query(&[("db_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::ResponseGetSessionRun`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::ResponseGetSessionRun`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSessionRunError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Retrieve all runs (executions) for a specific session with optional timestamp filtering. Runs represent individual interactions or executions within a session. Response schema varies based on session type.
pub async fn get_session_runs(
    configuration: &configuration::Configuration,
    session_id: &str,
    r#type: Option<models::SessionType>,
    user_id: Option<&str>,
    created_after: Option<i32>,
    created_before: Option<i32>,
    db_id: Option<&str>,
) -> Result<Vec<models::GetSessionRuns200ResponseInner>, Error<GetSessionRunsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_session_id = session_id;
    let p_query_type = r#type;
    let p_query_user_id = user_id;
    let p_query_created_after = created_after;
    let p_query_created_before = created_before;
    let p_query_db_id = db_id;

    let uri_str = format!(
        "{}/sessions/{session_id}/runs",
        configuration.base_path,
        session_id = crate::generated::apis::urlencode(p_path_session_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_user_id {
        req_builder = req_builder.query(&[("user_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_created_after {
        req_builder = req_builder.query(&[("created_after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_created_before {
        req_builder = req_builder.query(&[("created_before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_db_id {
        req_builder = req_builder.query(&[("db_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GetSessionRuns200ResponseInner&gt;`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GetSessionRuns200ResponseInner&gt;`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSessionRunsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Retrieve paginated list of sessions with filtering and sorting options. Supports filtering by session type (agent, team, workflow), component, user, and name. Sessions represent conversation histories and execution contexts.
pub async fn get_sessions(
    configuration: &configuration::Configuration,
    r#type: Option<models::SessionType>,
    component_id: Option<&str>,
    user_id: Option<&str>,
    session_name: Option<&str>,
    limit: Option<i32>,
    page: Option<i32>,
    sort_by: Option<&str>,
    sort_order: Option<models::SortOrder>,
    db_id: Option<&str>,
) -> Result<models::PaginatedResponseSessionSchema, Error<GetSessionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_type = r#type;
    let p_query_component_id = component_id;
    let p_query_user_id = user_id;
    let p_query_session_name = session_name;
    let p_query_limit = limit;
    let p_query_page = page;
    let p_query_sort_by = sort_by;
    let p_query_sort_order = sort_order;
    let p_query_db_id = db_id;

    let uri_str = format!("{}/sessions", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_component_id {
        req_builder = req_builder.query(&[("component_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_user_id {
        req_builder = req_builder.query(&[("user_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_session_name {
        req_builder = req_builder.query(&[("session_name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by {
        req_builder = req_builder.query(&[("sort_by", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_order {
        req_builder = req_builder.query(&[("sort_order", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_db_id {
        req_builder = req_builder.query(&[("db_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::PaginatedResponseSessionSchema`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedResponseSessionSchema`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSessionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Update the name of an existing session. Useful for organizing and categorizing sessions with meaningful names for better identification and management.
pub async fn rename_session(
    configuration: &configuration::Configuration,
    session_id: &str,
    body_rename_session: models::BodyRenameSession,
    r#type: Option<models::SessionType>,
    db_id: Option<&str>,
) -> Result<models::ResponseRenameSession, Error<RenameSessionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_session_id = session_id;
    let p_body_body_rename_session = body_rename_session;
    let p_query_type = r#type;
    let p_query_db_id = db_id;

    let uri_str = format!(
        "{}/sessions/{session_id}/rename",
        configuration.base_path,
        session_id = crate::generated::apis::urlencode(p_path_session_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_db_id {
        req_builder = req_builder.query(&[("db_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_body_rename_session);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::ResponseRenameSession`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::ResponseRenameSession`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RenameSessionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Update session properties such as session_name, session_state, metadata, or summary. Use this endpoint to modify the session name, update state, add metadata, or update the session summary.
pub async fn update_session(
    configuration: &configuration::Configuration,
    session_id: &str,
    update_session_request: models::UpdateSessionRequest,
    r#type: Option<models::SessionType>,
    user_id: Option<&str>,
    db_id: Option<&str>,
) -> Result<models::ResponseUpdateSession, Error<UpdateSessionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_session_id = session_id;
    let p_body_update_session_request = update_session_request;
    let p_query_type = r#type;
    let p_query_user_id = user_id;
    let p_query_db_id = db_id;

    let uri_str = format!(
        "{}/sessions/{session_id}",
        configuration.base_path,
        session_id = crate::generated::apis::urlencode(p_path_session_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_user_id {
        req_builder = req_builder.query(&[("user_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_db_id {
        req_builder = req_builder.query(&[("db_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_update_session_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::ResponseUpdateSession`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::ResponseUpdateSession`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateSessionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
