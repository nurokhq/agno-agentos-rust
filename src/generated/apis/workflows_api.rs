/*
 * Agno AgentOS
 *
 * Nurok AI's Agent OS
 *
 * The version of the OpenAPI document: 1.0.0
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{ContentType, Error, configuration};
use crate::generated::{apis::ResponseContent, models};
use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};

/// struct for typed errors of method [`cancel_workflow_run`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CancelWorkflowRunError {
    Status400(models::BadRequestResponse),
    Status401(models::UnauthenticatedResponse),
    Status404(models::NotFoundResponse),
    Status422(models::ValidationErrorResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_workflow_run`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateWorkflowRunError {
    Status400(models::BadRequestResponse),
    Status401(models::UnauthenticatedResponse),
    Status404(models::NotFoundResponse),
    Status422(models::ValidationErrorResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_workflow`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetWorkflowError {
    Status400(models::BadRequestResponse),
    Status401(models::UnauthenticatedResponse),
    Status404(models::NotFoundResponse),
    Status422(models::ValidationErrorResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_workflows`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetWorkflowsError {
    Status400(models::BadRequestResponse),
    Status401(models::UnauthenticatedResponse),
    Status404(models::NotFoundResponse),
    Status422(models::ValidationErrorResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`run_parse_workflow_workflows_parse_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RunParseWorkflowWorkflowsParsePostError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// Cancel a currently executing workflow run, stopping all active steps and cleanup. **Note:** Complex workflows with multiple parallel steps may take time to fully cancel.
pub async fn cancel_workflow_run(
    configuration: &configuration::Configuration,
    workflow_id: &str,
    run_id: &str,
) -> Result<serde_json::Value, Error<CancelWorkflowRunError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_workflow_id = workflow_id;
    let p_path_run_id = run_id;

    let uri_str = format!(
        "{}/workflows/{workflow_id}/runs/{run_id}/cancel",
        configuration.base_path,
        workflow_id = crate::generated::apis::urlencode(p_path_workflow_id),
        run_id = crate::generated::apis::urlencode(p_path_run_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `serde_json::Value`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CancelWorkflowRunError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Execute a workflow with the provided input data. Workflows can run in streaming or batch mode.  **Execution Modes:** - **Streaming (`stream=true`)**: Real-time step-by-step execution updates via SSE - **Non-Streaming (`stream=false`)**: Complete workflow execution with final result  **Workflow Execution Process:** 1. Input validation against workflow schema 2. Sequential or parallel step execution based on workflow design 3. Data flow between steps with transformation 4. Error handling and automatic retries where configured 5. Final result compilation and response  **Session Management:** Workflows support session continuity for stateful execution across multiple runs.
pub async fn create_workflow_run(
    configuration: &configuration::Configuration,
    workflow_id: &str,
    message: &str,
    stream: Option<bool>,
    session_id: Option<&str>,
    user_id: Option<&str>,
) -> Result<serde_json::Value, Error<CreateWorkflowRunError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_workflow_id = workflow_id;
    let p_form_message = message;
    let p_form_stream = stream;
    let p_form_session_id = session_id;
    let p_form_user_id = user_id;

    let uri_str = format!(
        "{}/workflows/{workflow_id}/runs",
        configuration.base_path,
        workflow_id = crate::generated::apis::urlencode(p_path_workflow_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("message", p_form_message.to_string());
    if let Some(param_value) = p_form_stream {
        multipart_form_params.insert("stream", param_value.to_string());
    }
    if let Some(param_value) = p_form_session_id {
        multipart_form_params.insert("session_id", param_value.to_string());
    }
    if let Some(param_value) = p_form_user_id {
        multipart_form_params.insert("user_id", param_value.to_string());
    }
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `serde_json::Value`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateWorkflowRunError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Retrieve detailed configuration and step information for a specific workflow.
pub async fn get_workflow(
    configuration: &configuration::Configuration,
    workflow_id: &str,
) -> Result<models::WorkflowResponse, Error<GetWorkflowError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_workflow_id = workflow_id;

    let uri_str = format!(
        "{}/workflows/{workflow_id}",
        configuration.base_path,
        workflow_id = crate::generated::apis::urlencode(p_path_workflow_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::WorkflowResponse`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::WorkflowResponse`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetWorkflowError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Retrieve a comprehensive list of all workflows configured in this OS instance.  **Return Information:** - Workflow metadata (ID, name, description) - Input schema requirements - Step sequence and execution flow - Associated agents and teams
pub async fn get_workflows(
    configuration: &configuration::Configuration,
) -> Result<Vec<models::WorkflowSummaryResponse>, Error<GetWorkflowsError>> {
    let uri_str = format!("{}/workflows", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::WorkflowSummaryResponse&gt;`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::WorkflowSummaryResponse&gt;`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetWorkflowsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Run the parse workflow  Args:     request: Parse workflow request  Returns:     Parse workflow result
pub async fn run_parse_workflow_workflows_parse_post(
    configuration: &configuration::Configuration,
    parse_workflow_request: models::ParseWorkflowRequest,
) -> Result<
    std::collections::HashMap<String, serde_json::Value>,
    Error<RunParseWorkflowWorkflowsParsePostError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_parse_workflow_request = parse_workflow_request;

    let uri_str = format!("{}/workflows/parse", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_parse_workflow_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `std::collections::HashMap&lt;String, serde_json::Value&gt;`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `std::collections::HashMap&lt;String, serde_json::Value&gt;`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RunParseWorkflowWorkflowsParsePostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
