/*
 * Agno AgentOS
 *
 * Nurok AI's Agent OS
 *
 * The version of the OpenAPI document: 1.0.0
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{ContentType, Error, UploadFile, configuration};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};

/// struct for typed errors of method [`cancel_workflow_run`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CancelWorkflowRunError {
    Status400(models::BadRequestResponse),
    Status401(models::UnauthenticatedResponse),
    Status404(models::NotFoundResponse),
    Status422(models::ValidationErrorResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_workflow_run`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateWorkflowRunError {
    Status400(models::BadRequestResponse),
    Status401(models::UnauthenticatedResponse),
    Status404(models::NotFoundResponse),
    Status422(models::ValidationErrorResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_workflow`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetWorkflowError {
    Status400(models::BadRequestResponse),
    Status401(models::UnauthenticatedResponse),
    Status404(models::NotFoundResponse),
    Status422(models::ValidationErrorResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_workflows`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetWorkflowsError {
    Status400(models::BadRequestResponse),
    Status401(models::UnauthenticatedResponse),
    Status404(models::NotFoundResponse),
    Status422(models::ValidationErrorResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`run_parse_workflow_workflows_parse_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RunParseWorkflowWorkflowsParsePostError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// Cancel a currently executing workflow run, stopping all active steps and cleanup. **Note:** Complex workflows with multiple parallel steps may take time to fully cancel.
pub fn cancel_workflow_run_request_builder(
    configuration: &configuration::Configuration,
    workflow_id: &str,
    run_id: &str,
) -> Result<reqwest::RequestBuilder, Error<serde_json::Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_workflow_id = workflow_id;
    let p_path_run_id = run_id;

    let uri_str = format!(
        "{}/workflows/{workflow_id}/runs/{run_id}/cancel",
        configuration.base_path,
        workflow_id = crate::apis::urlencode(p_path_workflow_id),
        run_id = crate::apis::urlencode(p_path_run_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    Ok(req_builder)
}

pub async fn cancel_workflow_run(
    configuration: &configuration::Configuration,
    workflow_id: &str,
    run_id: &str,
) -> Result<serde_json::Value, Error<CancelWorkflowRunError>> {
    let req_builder = cancel_workflow_run_request_builder(configuration, workflow_id, run_id)
        .map_err(super::map_request_builder_error)?;
    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `serde_json::Value`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CancelWorkflowRunError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Execute a workflow with the provided input data. Workflows can run in streaming or batch mode.  **Execution Modes:** - **Streaming (`stream=true`)**: Real-time step-by-step execution updates via SSE - **Non-Streaming (`stream=false`)**: Complete workflow execution with final result  **Workflow Execution Process:** 1. Input validation against workflow schema 2. Sequential or parallel step execution based on workflow design 3. Data flow between steps with transformation 4. Error handling and automatic retries where configured 5. Final result compilation and response  **Session Management:** Workflows support session continuity for stateful execution across multiple runs.
pub fn create_workflow_run_request_builder(
    configuration: &configuration::Configuration,
    workflow_id: &str,
    message: &str,
    stream: Option<bool>,
    session_id: Option<&str>,
    user_id: Option<&str>,
) -> Result<reqwest::RequestBuilder, Error<serde_json::Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_workflow_id = workflow_id;
    let p_form_message = message;
    let p_form_stream = stream;
    let p_form_session_id = session_id;
    let p_form_user_id = user_id;

    let uri_str = format!(
        "{}/workflows/{workflow_id}/runs",
        configuration.base_path,
        workflow_id = crate::apis::urlencode(p_path_workflow_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("message", p_form_message.to_string());
    if let Some(param_value) = p_form_stream {
        multipart_form_params.insert("stream", param_value.to_string());
    }
    if let Some(param_value) = p_form_session_id {
        multipart_form_params.insert("session_id", param_value.to_string());
    }
    if let Some(param_value) = p_form_user_id {
        multipart_form_params.insert("user_id", param_value.to_string());
    }
    req_builder = req_builder.form(&multipart_form_params);

    Ok(req_builder)
}

pub async fn create_workflow_run(
    configuration: &configuration::Configuration,
    workflow_id: &str,
    message: &str,
    stream: Option<bool>,
    session_id: Option<&str>,
    user_id: Option<&str>,
) -> Result<serde_json::Value, Error<CreateWorkflowRunError>> {
    let req_builder = create_workflow_run_request_builder(
        configuration,
        workflow_id,
        message,
        stream,
        session_id,
        user_id,
    )
    .map_err(super::map_request_builder_error)?;
    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `serde_json::Value`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateWorkflowRunError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Retrieve detailed configuration and step information for a specific workflow.
pub fn get_workflow_request_builder(
    configuration: &configuration::Configuration,
    workflow_id: &str,
) -> Result<reqwest::RequestBuilder, Error<serde_json::Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_workflow_id = workflow_id;

    let uri_str = format!(
        "{}/workflows/{workflow_id}",
        configuration.base_path,
        workflow_id = crate::apis::urlencode(p_path_workflow_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    Ok(req_builder)
}

pub async fn get_workflow(
    configuration: &configuration::Configuration,
    workflow_id: &str,
) -> Result<models::WorkflowResponse, Error<GetWorkflowError>> {
    let req_builder = get_workflow_request_builder(configuration, workflow_id)
        .map_err(super::map_request_builder_error)?;
    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::WorkflowResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::WorkflowResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetWorkflowError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Retrieve a comprehensive list of all workflows configured in this OS instance.  **Return Information:** - Workflow metadata (ID, name, description) - Input schema requirements - Step sequence and execution flow - Associated agents and teams
pub fn get_workflows_request_builder(
    configuration: &configuration::Configuration,
) -> Result<reqwest::RequestBuilder, Error<serde_json::Error>> {
    let uri_str = format!("{}/workflows", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    Ok(req_builder)
}

pub async fn get_workflows(
    configuration: &configuration::Configuration,
) -> Result<Vec<models::WorkflowSummaryResponse>, Error<GetWorkflowsError>> {
    let req_builder =
        get_workflows_request_builder(configuration).map_err(super::map_request_builder_error)?;
    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::WorkflowSummaryResponse&gt;`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::WorkflowSummaryResponse&gt;`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetWorkflowsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Run the parse workflow  Args:     request: Parse workflow request  Returns:     Parse workflow result
pub fn run_parse_workflow_workflows_parse_post_request_builder(
    configuration: &configuration::Configuration,
    parse_workflow_request: models::ParseWorkflowRequest,
) -> Result<reqwest::RequestBuilder, Error<serde_json::Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_parse_workflow_request = parse_workflow_request;

    let uri_str = format!("{}/workflows/parse", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_parse_workflow_request);

    Ok(req_builder)
}

pub async fn run_parse_workflow_workflows_parse_post(
    configuration: &configuration::Configuration,
    parse_workflow_request: models::ParseWorkflowRequest,
) -> Result<
    std::collections::HashMap<String, serde_json::Value>,
    Error<RunParseWorkflowWorkflowsParsePostError>,
> {
    let req_builder = run_parse_workflow_workflows_parse_post_request_builder(
        configuration,
        parse_workflow_request,
    )
    .map_err(super::map_request_builder_error)?;
    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `std::collections::HashMap&lt;String, serde_json::Value&gt;`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `std::collections::HashMap&lt;String, serde_json::Value&gt;`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RunParseWorkflowWorkflowsParsePostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
